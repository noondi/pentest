#!/bin/bash
RESET='\033[00m'; # No Color
LRED='\033[1;31m';
ORANGE='\033[0;33m';
LGREEN='\033[1;32m';
GREEN='\033[0;32m';
cmdTITLE='';
cmdRESPONSE='';

operatingSYSTEM(){
  cmdTITLE="OPERATING SYSTEM";
  cmdSTATUStitle;

  # distribution
  cmdSUBTITLE="Distribution";
  cmdRESPONSE=$($catCMD /etc/*-release 2>&1;);
  cmdSTATUSsubtitle;

  # kernel
  cmdSUBTITLE="Kernel";
  cmdRESPONSE=$(if [ -f /proc/version ]; then cat /proc/version 2>&1; else $unameCMD -a 2>&1; fi;);
  cmdSTATUSsubtitle;

  cmdSUBTITLE="Environment Variables";
  cmdRESPONSE=$($envCMD | $grepCMD -v "LS_COLORS" 2>&1;);
  cmdSTATUSsubtitle;

  # printer
  cmdSUBTITLE="Printer";
  cmdRESPONSE=$($lpstatCMD -a 2>&1;);
  cmdSTATUSsubtitle;
}

netWORK(){
  cmdTITLE="NETWORK";
  cmdSTATUStitle;

  # nic
  cmdSUBTITLE="Network Interfaces";
  cmdRESPONSE=$(if [ -f $ifconfigCMD ]; then $ifconfigCMD 2>&1; else $ipCMD a 2>&1; fi;);
  cmdSTATUSsubtitle;

  # dns resolver
  cmdSUBTITLE="DNS Resolver";
  cmdRESPONSE=$($catCMD /etc/resolv.conf 2>&1;);
  cmdSTATUSsubtitle;

  # hostname
  cmdSUBTITLE="Hostname";
  cmdRESPONSE=$($hostnameCMD 2>&1;);
  cmdSTATUSsubtitle;
}

userACCOUNTS(){
  cmdTITLE="USERS";
  cmdSTATUStitle;

  # who logged last on the system
  cmdSUBTITLE="All users";
  cmdRESPONSE=$($catCMD /etc/passwd 2>&1;);
  cmdSTATUSsubtitle;

  # list id
  cmdSUBTITLE="My ID";
  cmdRESPONSE=$($idCMD 2>&1;);
  cmdSTATUSsubtitle;

  # who is on the system
  cmdSUBTITLE="Who's logged right now";
  cmdRESPONSE=$($whoCMD 2>&1; w 2>&1;);
  cmdSTATUSsubtitle;

  # who logged last
  cmdSUBTITLE="Who's logged last";
  cmdRESPONSE=$($lastCMD);
  cmdSTATUSsubtitle;

  # list super users
  cmdSUBTITLE="Super users";
  cmdRESPONSE=$($catCMD /etc/passwd | $awkCMD -F: '($3 == 0) { print $1 }' 2>&1;);
  cmdSTATUSsubtitle;

  # list shadow file
  cmdSUBTITLE="Shadow file";
  cmdRESPONSE=$($catCMD /etc/shadow 2>&1;);
  cmdSTATUSsubtitle;
}

fileSYSTEMS(){
  cmdTITLE="FILE SYSTEMS";
  cmdSTATUStitle;

  # checking root's home folder
  cmdSUBTITLE="root's home folder accessibility";
  cmdRESPONSE=$($lsCMD -lt /root/ 2>&1;);
  cmdSTATUSsubtitle;

  # list world writeable directories owned by user/group root
  cmdSUBTITLE="World Writeables Directories for User/Group 'root'";
  cmdRESPONSE=$($findCMD / -perm -o+w -type d -user root -group root 2>/dev/null | $grepCMD -v /proc | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;

  # list world writeable directories owned by other usersroot
  cmdSUBTITLE="World Writeables Directories for non-root Users";
  cmdRESPONSE=$($findCMD / -perm -o+w -type d ! -user root ! -group root 2>/dev/null | $grepCMD -v /proc | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;

  # list world writeable files
  cmdSUBTITLE="World Writeables Files";
  cmdRESPONSE=$($findCMD / -perm -o+w -type f 2>/dev/null | $grepCMD -v /proc | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;

  # Sticky bits, SUID & SGID files and directories
  cmdSUBTITLE="Sticky bits";
  cmdRESPONSE=$($findCMD / -perm -1000 -type d 2>/dev/null | $grepCMD -v /proc | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;
  cmdSUBTITLE="SUID";
  cmdRESPONSE=$($findCMD / -perm -g=s -type f 2>/dev/null | $grepCMD -v /proc | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;
  cmdSUBTITLE="GUID";
  cmdRESPONSE=$($findCMD / -perm -1000 -type d 2>/dev/null | $grepCMD -v /proc | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;

  # logs containing keyword 'password'


  # config files containing keyword 'password'
  cmdSUBTITLE="Configuration files containing keyword 'password'";
  cmdRESPONSE=$($findCMD / -name "*.conf" -print0 | xargs -0 grep -i -n "password" 2>/dev/null | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;
}

applicationSERVICES(){
  cmdTITLE="APPLICATIONS & SERVICES";
  cmdSTATUStitle;

  # installed packages

  # list running services
  cmdSUBTITLE="Running Services";
  cmdRESPONSE=$($psCMD ax -o user,pid,time,cmd;);
  cmdSTATUSsubtitle;

  # list sudo version
  cmdSUBTITLE="Sudo version";
  cmdRESPONSE=$($sudoCMD -V;);
  cmdSTATUSsubtitle;

  # list processes and packages running as root or other superuser


  # look for installed tools
}

cmdSTATUStitle(){
  echo -e "${LGREEN}=============================================";
  echo -e "${LGREEN}[*] $cmdTITLE...";
  echo -e "${LGREEN}=============================================${RESET}";
  printf "\n";
  sleep .5s;
}

cmdSTATUSsubtitle(){
  if [ $? -eq 0 ]; then
    echo -e "${LGREEN}[+] $cmdSUBTITLE${GREEN}";
    printf "$cmdRESPONSE\n\n";
  else
    echo -e "${LRED}[!] $cmdSUBTITLE${ORANGE}";
    printf "$cmdRESPONSE\n\n";
  fi
  sleep .5s;
}

# lookup bin in various pathes so that I don't depent on the $PATH env
lookupBIN(){
  if [[ -e /bin/$1 ]]; then
    echo /bin/$1;
  elif [[ -e /sbin/$1 ]]; then
    echo /sbin/$1;
  elif [[ -e /usr/bin/$1 ]]; then
    echo /usr/bin/$1;
  elif [[ -e /usr/locadl/$1 ]]; then
    echo /usr/local/$1;
  elif [[ -e /usr/local/bin/$1 ]]; then
    echo /usr/local/bin/$1;
  elif [[ -e /urs/local/sbin/$1 ]]; then
    echo /urs/local/sbin/$1;
  else
    echo $1": command not found";
    # this is to give me a fail status
    fdsafsda 2>/dev/null;
  fi
}

# initializing commands so that I don't depent on the $PATH env
catCMD=$(lookupBIN cat);
unameCMD=$(lookupBIN uname);
envCMD=$(lookupBIN env);
grepCMD=$(lookupBIN grep);
lpstatCMD=$(lookupBIN lpstat);
hostnameCMD=$(lookupBIN hostname);
idCMD=$(lookupBIN id);
whoCMD=$(lookupBIN who);
lastCMD=$(lookupBIN last);
awkCMD=$(lookupBIN awk);
psCMD=$(lookupBIN ps);
ifconfigCMD=$(lookupBIN ifconfig);
ipCMD=$(lookupBIN ip);
lsCMD=$(lookupBIN ls);
findCMD=$(lookupBIN find);
sudoCMD=$(lookupBIN sudo);

start(){
  operatingSYSTEM;
  netWORK;
  userACCOUNTS;
  fileSYSTEMS;
  applicationSERVICES;
}

start;
